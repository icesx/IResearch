### 装饰器模式 

*动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。不改变接口的前提下，增强所考虑的类的性能*

1. 装饰模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。
2. 透明的装饰模式也就是理想的装饰模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。
3. 相反，如果装饰角色的接口与抽象构件角色接口不一致，也就是说装饰角色的接口比抽象构件角色的接口宽的话，装饰角色实际上已经成了一个适配器角色，这种装饰模式也是可以接受的，称为“半透明”的装饰模式

### 特点
1. 抽象装饰器和具体被装饰的对象实现同一个接口
2. 抽象装饰器里面要持有接口对象，以便请求传递
3. 具体装饰器覆盖抽象装饰器方法并用super进行调用，传递请求

### 与代理模式区别
1. 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。
2. 因此，当使用代理模式的时候，我们常常在**一个代理类中创建一个对象的实例**。并且，当我们使用装饰器模 式的时候，我们通常的做法是将**原始对象作为一个参数传给装饰者的构造器**。

3. 我们可以用另外一句话来总结这些差别：使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。



### 特征代码

```java
public class FooterDecorator extends OrderDecorator {
	public FooterDecorator(Order anOrder) {
		super(anOrder);
	}

	public void print() {
		super.order.print();
		printFooter();
	}

	private void printFooter() {

		System.out.println("========================================================");
		System.out.println("Total\t\t\t\t" + formatCurrency(super.order.getGrandTotal()));
	}

}
```

